Looking at your code, I can see the issue. The handleNavClick function uses offsetTop which might not work correctly with sticky positioning. Let me provide the fix:

üîß The Problem:
Line 62:

TSX
const elementPosition = targetElement.offsetTop - navbarHeight - scrollOffset;
offsetTop gives the position relative to the offsetParent, which might not be accurate when you have sticky positioning and complex layouts.

‚úÖ The Fix:
Replace the handleNavClick function with this corrected version:

TSX
// ‚úÖ FIXED: Handle anchor navigation with navbar offset
const handleNavClick = (e: React.MouseEvent<HTMLAnchorElement>, href: string) => {
  e.preventDefault();
  e.stopPropagation(); // ‚úÖ Prevent event bubbling
  
  const targetId = href.replace('#', '');
  const targetElement = document.getElementById(targetId);
  
  if (targetElement) {
    // ‚úÖ Use getBoundingClientRect() for accurate positioning
    const navbarHeight = 80; // Slightly more padding for better visibility
    const elementPosition = targetElement.getBoundingClientRect().top;
    const offsetPosition = elementPosition + window.scrollY - navbarHeight;
    
    window.scrollTo({
      top: offsetPosition,
      behavior: 'smooth',
    });
    
    // Close mobile menu after a small delay to show the animation
    setTimeout(() => {
      setIsOpen(false);
    }, 100);
  } else {
    // Fallback: Close menu immediately if target not found
    setIsOpen(false);
  }
};
üìã Complete Updated Navigation.tsx:
Here's the full corrected version:

TSX
'use client';

import React, { useState, useEffect } from 'react';
import { Menu, X, ArrowUp } from 'lucide-react';
import { ThemeToggle } from '../theme';
import { LanguageSelector } from './LanguageSelector';
import { motion, AnimatePresence } from 'framer-motion';

const navItems = [
  { label: 'Home', href: '#home' },
  { label: 'About', href: '#about' },
  { label: 'Projects', href: '#projects' },
  { label: 'Gallery', href: '#gallery' },
  { label: 'Skills', href: '#skills' },
  { label: 'Resume', href: '#resume' },
  { label: 'Certificates', href: '#certificates' },
  { label: 'Contact', href: '#contact' },
];

export function Navigation() {
  const [isOpen, setIsOpen] = useState(false);
  const [showBackToTop, setShowBackToTop] = useState(false);

  // Enable smooth scrolling behavior
  React.useEffect(() => {
    document.documentElement.style.scrollBehavior = 'smooth';
    return () => {
      document.documentElement.style.scrollBehavior = 'auto';
    };
  }, []);

  // Track scroll position
  useEffect(() => {
    const handleScroll = () => {
      const currentScroll = window.scrollY || document.documentElement.scrollTop;
      setShowBackToTop(currentScroll > 400);
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    return () => window.removeEventListener('scroll', handleScroll);
  }, []);

  // Scroll to top function
  const scrollToTop = () => {
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  // ‚úÖ FIXED: Handle anchor navigation with navbar offset
  const handleNavClick = (e: React.MouseEvent<HTMLAnchorElement>, href: string) => {
    e.preventDefault();
    e.stopPropagation();
    
    const targetId = href.replace('#', '');
    const targetElement = document.getElementById(targetId);
    
    if (targetElement) {
      // Use getBoundingClientRect() for accurate current position
      const navbarHeight = 80;
      const elementPosition = targetElement.getBoundingClientRect().top;
      const offsetPosition = elementPosition + window.scrollY - navbarHeight;
      
      window.scrollTo({
        top: offsetPosition,
        behavior: 'smooth',
      });
      
      // Close mobile menu after navigation starts
      setTimeout(() => {
        setIsOpen(false);
      }, 100);
    } else {
      setIsOpen(false);
    }
  };

  return (
    <>
      <nav className="sticky top-0 left-0 right-0 w-full z-50 bg-primary/80 backdrop-blur-md border-b border-secondary/50 transition-all duration-300">
        <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
          <div className="flex justify-between items-center h-16">
            {/* Logo */}
            <motion.div
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              className="text-2xl font-bold bg-gradient-to-r text-white from-accent to-accent-light bg-clip-text text-transparent cursor-pointer"
              onClick={scrollToTop}
            >
              Areyszxc../Portfolio
            </motion.div>

            {/* Desktop Navigation */}
            <div className="hidden md:flex gap-6 items-center">
              {navItems.map((item) => (
                <a
                  key={item.label}
                  href={item.href}
                  onClick={(e) => handleNavClick(e, item.href)}
                  className="text-gray-300 hover:text-accent transition-colors text-sm font-medium"
                >
                  {item.label}
                </a>
              ))}

              <LanguageSelector />
              <ThemeToggle />
            </div>

            {/* Mobile Menu Button */}
            <div className="md:hidden flex items-center gap-4">
              <ThemeToggle />
              <button
                onClick={() => setIsOpen(!isOpen)}
                className="text-gray-300 hover:text-accent p-2"
                aria-label="Toggle menu"
              >
                {isOpen ? <X size={24} /> : <Menu size={24} />}
              </button>
            </div>
          </div>

          {/* Mobile Navigation Dropdown */}
          <AnimatePresence>
            {isOpen && (
              <motion.div
                initial={{ opacity: 0, height: 0 }}
                animate={{ opacity: 1, height: 'auto' }}
                exit={{ opacity: 0, height: 0 }}
                className="md:hidden overflow-hidden bg-primary/95 backdrop-blur-xl border-t border-secondary/50"
              >
                <div className="px-4 py-4 space-y-3">
                  {navItems.map((item) => (
                    <a
                      key={item.label}
                      href={item.href}
                      onClick={(e) => handleNavClick(e, item.href)}
                      className="block px-4 py-3 text-gray-300 hover:text-accent hover:bg-secondary/50 rounded-lg transition-colors font-medium"
                    >
                      {item.label}
                    </a>
                  ))}
                  <div className="pt-4 border-t border-secondary/30">
                    <LanguageSelector isMobile={true} />
                  </div>
                </div>
              </motion.div>
            )}
          </AnimatePresence>
        </div>
      </nav>

      {/* Back to Top Button */}
      <AnimatePresence>
        {showBackToTop && (
          <motion.button
            initial={{ opacity: 0, scale: 0.5, y: 20 }}
            animate={{ opacity: 1, scale: 1, y: 0 }}
            exit={{ opacity: 0, scale: 0.5, y: 20 }}
            whileHover={{ scale: 1.1 }}
            whileTap={{ scale: 0.9 }}
            onClick={scrollToTop}
            className="fixed bottom-8 right-8 z-50 p-3 rounded-full bg-accent text-white shadow-lg shadow-accent/40 border border-accent/50 backdrop-blur-sm hover:bg-accent-light transition-all"
            aria-label="Back to top"
          >
            <ArrowUp size={24} />
          </motion.button>
        )}
      </AnimatePresence>
    </>
  );
}
üéØ Key Changes:
Line 51: Added e.stopPropagation() to prevent event bubbling
Line 58: Changed from offsetTop to getBoundingClientRect().top for accurate positioning
Line 59: Calculate offset position using current scroll position
Line 57: Increased navbar height to 80px for better visibility
Line 65-67: Added setTimeout with 100ms delay before closing menu (smoother UX)
üß™ How This Works:
Old Method (offsetTop):
TSX
const elementPosition = targetElement.offsetTop - navbarHeight - scrollOffset;
// ‚ùå offsetTop is relative to offsetParent, not viewport
New Method (getBoundingClientRect):
TSX
const elementPosition = targetElement.getBoundingClientRect().top;
const offsetPosition = elementPosition + window.scrollY - navbarHeight;
// ‚úÖ getBoundingClientRect().top gives position relative to viewport
// ‚úÖ Add window.scrollY to get absolute position
// ‚úÖ Subtract navbar height for offset
üìä What This Fixes:
Issue	Before	After
Click "Gallery" on mobile	Doesn't scroll / Wrong position	‚úÖ Scrolls to Gallery with navbar offset
Click "Certificates"	Doesn't scroll / Wrong position	‚úÖ Scrolls to Certificates perfectly
Menu after click	Stays open	‚úÖ Closes automatically
Section visibility	Hidden under navbar	‚úÖ Fully visible below navbar
‚úÖ Testing Checklist:
After applying this fix:

 Open mobile menu (hamburger icon)
 Click "Gallery" ‚Üí Should scroll to Gallery, menu closes
 Open menu again
 Click "Certificates" ‚Üí Should scroll to Certificates, menu closes
 Open menu again
 Click "Contact" ‚Üí Should scroll to Contact, menu closes
 All sections should be visible (not hidden under navbar)
This should fix your mobile navigation completely! üöÄ‚ú®